"""update crossword data schema and datetime instead of data for logs

Revision ID: 6596b86a98a1
Revises: 280b8a4bf14d
Create Date: 2025-12-03 21:26:51.024987

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '6596b86a98a1'
down_revision: Union[str, None] = '280b8a4bf14d'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    source_enum = sa.Enum('nyt', name='puzzle_source_enum')
    variant_enum = sa.Enum('daily', 'mini', 'bonus', name='puzzle_variant_enum')
    source_enum.create(op.get_bind(), checkfirst=True)
    variant_enum.create(op.get_bind(), checkfirst=True)

    op.add_column('crossword_data',
        sa.Column('source', source_enum, nullable=True)
    )
    op.add_column('crossword_data',
        sa.Column('variant', variant_enum, nullable=True)
    )

    op.execute("""
        UPDATE crossword_data
        SET source = 'nyt',
            variant = CASE
                WHEN puzzle_type = 'nyt_daily' THEN 'daily'::puzzle_variant_enum
                WHEN puzzle_type = 'nyt_mini'  THEN 'mini'::puzzle_variant_enum
                ELSE NULL
            END
    """)

    op.alter_column('crossword_data', 'source', nullable=False)
    op.alter_column('crossword_data', 'variant', nullable=False)

    op.alter_column('crossword_data', 'last_fetched',
               existing_type=sa.DATE(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    op.alter_column('crossword_data', 'day', new_column_name='date')

    op.drop_constraint('unique_user_day_puzzle_type', 'crossword_data', type_='unique')
    op.create_unique_constraint('unique_user_date_puzzle_type', 'crossword_data', ['user_id', 'date', 'source', 'variant'])
    op.create_check_constraint(
    "valid_source_variant",
    "crossword_data",
    "(source = 'nyt' AND variant IN ('daily', 'mini', 'bonus'))"
)

    op.drop_column('crossword_data', 'puzzle_type')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    puzzle_type_enum = postgresql.ENUM('nyt_daily', 'nyt_mini', name='puzzle_type_enum')
    puzzle_type_enum.create(op.get_bind(), checkfirst=True)

    op.add_column('crossword_data',
        sa.Column('puzzle_type', puzzle_type_enum, nullable=True)
    )

    # Backfill puzzle_type from source + variant
    op.execute("""
        UPDATE crossword_data
        SET puzzle_type =
            CASE
                WHEN source='nyt' AND variant='daily' THEN 'nyt_daily'::puzzle_type_enum
                WHEN source='nyt' AND variant='mini' THEN 'nyt_mini'::puzzle_type_enum
                ELSE NULL
            END
    """)

    # Make puzzle_type NOT NULL
    op.alter_column('crossword_data', 'puzzle_type', nullable=False)


    op.alter_column('crossword_data', 'last_fetched',
               existing_type=sa.DateTime(timezone=True),
               type_=sa.DATE(),
               existing_nullable=True)

    op.drop_constraint('unique_user_date_puzzle_type', 'crossword_data', type_='unique')
    op.alter_column('crossword_data', 'date', new_column_name='day')
    op.drop_constraint("valid_source_variant", "crossword_data", type_="check")
    op.create_unique_constraint('unique_user_day_puzzle_type', 'crossword_data', ['user_id', 'day', 'puzzle_type'])
    
        # Remove new fields
    op.drop_column('crossword_data', 'variant')
    op.drop_column('crossword_data', 'source')

    # ### end Alembic commands ###
